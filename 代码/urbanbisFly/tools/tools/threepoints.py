import numpy as np

"""
给出三点配准出一个刚性变换矩阵
"""
def inverse_rigid_transform(matrix):
    """
    Computes the inverse of a 4x4 rigid transformation matrix.

    Parameters:
    matrix (np.ndarray): A 4x4 rigid transformation matrix.

    Returns:
    np.ndarray: The inverse of the given 4x4 rigid transformation matrix.
    """
    assert matrix.shape == (4, 4), "Input matrix must be a 4x4 matrix"

    # Create an identity matrix for the inverse
    inverse_matrix = np.eye(4)

    # Transpose the 3x3 rotation part
    inverse_matrix[:3, :3] = matrix[:3, :3].T

    # Adjust the translation part
    inverse_matrix[:3, 3] = -np.dot(inverse_matrix[:3, :3], matrix[:3, 3])

    return inverse_matrix
#yuehai
#=====================================
#原始OBJ和原始点云的转换方式 此处是将OBJ转到点云的体系当中
# -0.99995155 -0.00945041 -0.00275363 -6895.69480337
# -0.00277162 0.00189163 0.99999437 7039.89155408
# -0.00944514 0.99995355 -0.00191773 -69.85406940
# 0.00000000 0.00000000 0.00000000 1.00000000


# 定义源点和目标点 obj与标签点云
# A = np.array([
#     [-6537.17, 94.38, -7007.04],
#     [-6589.85, 93.93, -7056.11],
#     [-6619.20,86.43, -6643.17]
# ])
# B = np.array([
#     [339.51, 52.29, 99.67],
#     [288.21, 2.47, 99.85],
#     [259.68, 413.96, 91.86]
# ])



#---------点云到obj---
# -0.99991084 -0.01335037 0.00026453 -6879.18418223
# 0.00061274 -0.02608540 0.99965953 -4.25775708
# -0.01333892 0.99957057 0.02609125 -7062.17947779
# 0.00000000 0.00000000 0.00000000 1.00000000

# A = np.array([
#     [-304,20,126],
#     [-288, 0, 98],
#     [-290,50, 100]
# ])
#
# B = np.array([
#     [-6576.02,119.98,-7035.37],
#     [-6590.72,94.39,-7056.59],
#     [-6589.74,94.38,-7004.39]
# ])
#========================================
#用深度图扫描的点云图与obj的 不需要转置
#局部坐标系转obj
# -0.88054843 0.00484922 -0.47393138 -6634.84817675
# -0.00654431 -0.99997673 0.00192744 117.67504281
# -0.47391101 0.00479876 0.88055967 -7057.02664942
# 0.00000000 0.00000000 0.00000000 1.00000000

# A = np.array([
#     [104.39, 68.79, -14.57],
#     [122.39, 64.56, -23.08],
#     [151.01, 68.36, 23.41]
# ])
#
# B = np.array([
#     [-6719.5, 48.19, -7119.07],
#     [-6731.40,52.24,-7134.94],
#     [-6778.58,48.38,-7107.68]
# ])
#obj转局部坐标系
# 0.00747532 0.00355394 0.99996574 7128.15722763
# -0.00404680 -0.99998539 0.00358426 90.62354574
# 0.99996387 -0.00407345 -0.00746083 6538.29701216
# 0.00000000 0.00000000 0.00000000 1.00000000


#qingdao
# 点云-》mesh
# 0.99999959 -0.00041826 0.00080255 43.31841575
# -0.00080256 -0.00002720 0.99999968 -200.61969388
# 0.00041824 0.99999991 0.00002754 76.14872781
# 0.00000000 0.00000000 0.00000000 1.00000000
#mesh->点云
# 0.99999959 -0.00080256 0.00041824 -43.51125578
# -0.00041826 -0.00002720 0.99999991 -76.13606046
# 0.00080255 0.99999968 0.00002754 200.58276691
# 0.00000000 0.00000000 0.00000000 1.00000000
# mesh->亚局部
# -0.00589500 0.00048018 0.99998251 131.16643871
# 0.00020221 -0.99999986 0.00048138 -115.98506379
# 0.99998260 0.00020504 0.00589490 40.25362765
# 0.00000000 0.00000000 0.00000000 1.00000000
# 亚局部-》mesh
# -0.00589500 0.00020221 0.99998260 -39.45624837
# 0.00048018 -0.99999986 0.00020504 -116.05628503
# 0.99998251 0.00048138 0.00589490 -131.34560279
# 0.00000000 0.00000000 0.00000000 1.00000000


#============yingrenshi=========
# 将A投影到B中

#dianyun->mesh
# A= np.array([
#     [-70,-49,61],
#     [-105,-30,30],
#     [-108,30,31]
# ])
# B= np.array([
#     [-67, 68,-66],
#     [-101, 36, -47],
#     [-103, 37, 13]
# ])
# B= np.array([
#     [-70,-49,61],
#     [-105,-30,30],
#     [-108,30,31]
# ])
# A= np.array([
#     [-67, 68,-66],
#     [-101, 36, -47],
#     [-103, 37, 13]
# ])
#mesh到伪局部
# B= np.array([
#     [6,-31,-19],
#     [36,-32,-14],
#     [-14,-35,-8]
# ])
# A= np.array([
#     [-1, 40,-0.1],
#     [3, 42, 30],
#     [10, 43, -20]
# ])

#wuhu
# #mesh->yajubu
# B= np.array([
#     [-63,-105,-73],
#     [-127,-80,-123],
#     [-106,-98,4]
# ])
# A= np.array([
#     [-5, 84,110],
#     [-54, 61, 44],
#     [71, 79, 68]
# ])
# #============LIHU======
# A= np.array([
#     [24.30,104.23,81.04],
#     [-12.67,113.35,-67.68],
#     [37.19,110.98,-68.97]
# ])
# B= np.array([
#     [26.78,104.16,81.07],
#     [-11.37, 113.46, -68.69],
#     [35.93, 110.88, -69.27]
# ])

#------------wuhu------
# B= np.array([
#     [238,1158,101],
#     [135,883,185],
#     [179,833,97]
# ])
# A= np.array([
#     [82, 101,1085],
#     [-19, 184, 809],
#     [21, 97, 762]
# ])
#yuehai
#mesh->yajubu
# A= np.array([
#     [-6925.92,-126.404,-7049.037],
#     [-6741.702,-112.45,-7064.975],
#     [-6861.167,-124.623,-6986.299]
# ])
# B= np.array([
#     [13.70, 103.33,-50.68],
#     [-7.86, 91.869, 133.81],
#     [74.816, 102.16, 15.11]
# ])
# A= np.array([
#     [-44.473,47.83,69.201],
#     [-62.806,51.369,51.535],
#     [14.977,46.979,77.399]
# ])
# B= np.array([
#     [-36.795, 44.039,71.652],
#     [-56.563, 47.554, 53.958],
#     [22.507, 43.916, 78.864]
# ])

#-------------------
#yingrenshit
# A= np.array([
#     [-4.09,8.57,-1.79],
#     [27.29,16.51,-14.26],
#     [30.35,18.32,26.18]
# ])
# B= np.array([
#     [-25.74, 21.75,-16.25],
#     [5.41, 30.18,-29.45],
#     [9.13, 32.42, 11.08]
# ])
A= np.array([
    [21.34,47.60,-27.95],
    [-32.36,52.25,-76.89],
    [-57.07,50.55,1.39]
])
B= np.array([
    [30.71, 45.22,-28.47],
    [-24.5, 54.43,-75.88],
    [-47.59, 46.05, 2.35]
])
# A= np.array([
#     [-33, 49.02,17.54],
#     [68.71, 46.04,-94.54],
#     [-90.35, 47.67, 3.76]
# ])
# B= np.array([
#     [-25.22,38.96,4.75],
#     [78.5,35.93,-103.2],
#     [-81.9,38.05,-8.57]
# ])
# B= np.array([
#     [-17.13, -40.57,-40.84],
#     [-0.74, -39.88,7.25],
#     [46.12, -25.31, -7.12]
# ])
# A= np.array([
#     [-23.54,45.75,-30.62],
#     [24.23,45.26,-13.01],
#     [8.56,30.37,33.2]
# ])
# 计算质心
centroid_A = np.mean(A, axis=0)
centroid_B = np.mean(B, axis=0)

# 将点平移使质心在原点
A_centered = A - centroid_A
B_centered = B - centroid_B

# 计算旋转矩阵
H = np.dot(A_centered.T, B_centered)
U, S, Vt = np.linalg.svd(H)
R = np.dot(Vt.T, U.T)

# 确保旋转矩阵的正交性
# if np.linalg.det(R) > 0:
#     print("true")
Vt[2, :] *= -1
R = np.dot(Vt.T, U.T)

# 计算平移向量ddddddddd
t = centroid_B - np.dot(R, centroid_A)

# 构建刚性变换矩阵
T = np.identity(4)
T[:3, :3] = R
T[:3, 3] = t


# # 定义x坐标乘以-1的变换矩阵
# mirror_x_matrix = np.array([
#     [-1, 0, 0, 0],
#     [0, 1, 0, 0],
#     [0, 0, 1, 0],
#     [0, 0, 0, 1]
# ])
# T = mirror_x_matrix @ T

for row in T:
    print(" ".join(f"{value:.8f}" for value in row))



# print("=====")
# a = np.array([
#     [0.99995317, 0.00878317 ,0.00406468 ,1.14451620],
#     [-0.00878159, 0.99996136, -0.00040617, 5.71135790],
#     [-0.00406809, 0.00037045, 0.99999166, -2.46603199],
#     [0.00000000, 0.00000000, 0.00000000, 1.00000000
# ]
# ])
# b = np.array([
#     [0.99998953, -0.00447939, 0.00093300, -4.48697151],
#     [-0.00093309, -0.00001939, 0.99999956, -19.57629683],
#     [0.00447937, 0.99998997, 0.00002357, -54.91117595],
#     [0.00000000, 0.00000000, 0.00000000, 1.00000000]
# ])
# c = a @ b
# c= np.linalg.inv(c)
# print("==========")
# for row in c:
#     print(" ".join(f"{value:.8f}" for value in row))
